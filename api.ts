/* tslint:disable */
/* eslint-disable */
/**
 * Blockmate
 * Blockmate API OpenAPI documentation
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Represents an account.
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'type': AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'url': string;
}

export const AccountTypeEnum = {
    Wallet: 'crypto_wallet',
    Exchange: 'crypto_exchange',
    Nft: 'crypto_nft'
} as const;

export type AccountTypeEnum = typeof AccountTypeEnum[keyof typeof AccountTypeEnum];

/**
 * Account provider
 * @export
 * @interface AccountProvider
 */
export interface AccountProvider {
    /**
     * 
     * @type {string}
     * @memberof AccountProvider
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountProvider
     */
    'type': AccountProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountProvider
     */
    'url': string;
}

export const AccountProviderTypeEnum = {
    Wallet: 'crypto_wallet',
    Exchange: 'crypto_exchange',
    Nft: 'crypto_nft'
} as const;

export type AccountProviderTypeEnum = typeof AccountProviderTypeEnum[keyof typeof AccountProviderTypeEnum];

/**
 * Account provider hint containing info about what is needed to connect such an account
 * @export
 * @interface AccountProviderHint
 */
export interface AccountProviderHint {
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHint
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHint
     */
    'account_type': AccountProviderHintAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHint
     */
    'account_url': string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHint
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHint
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHint
     */
    'intro'?: string;
    /**
     * 
     * @type {AccountProviderHintFields}
     * @memberof AccountProviderHint
     */
    'fields': AccountProviderHintFields;
    /**
     * 
     * @type {boolean}
     * @memberof AccountProviderHint
     */
    'oauth': boolean;
}

export const AccountProviderHintAccountTypeEnum = {
    Wallet: 'crypto_wallet',
    Exchange: 'crypto_exchange',
    Nft: 'crypto_nft'
} as const;

export type AccountProviderHintAccountTypeEnum = typeof AccountProviderHintAccountTypeEnum[keyof typeof AccountProviderHintAccountTypeEnum];

/**
 * 
 * @export
 * @interface AccountProviderHintFields
 */
export interface AccountProviderHintFields {
    [key: string]: string | any;

    /**
     * 
     * @type {string}
     * @memberof AccountProviderHintFields
     */
    'api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHintFields
     */
    'api_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHintFields
     */
    'api_passphrase'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHintFields
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountProviderHintFields
     */
    'wallet'?: string;
}
/**
 * AddressRiskReport
 * @export
 * @interface AddressRiskReport
 */
export interface AddressRiskReport {
    /**
     * 
     * @type {string}
     * @memberof AddressRiskReport
     */
    'case_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRiskReport
     */
    'request_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRiskReport
     */
    'response_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRiskReport
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressRiskReport
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof AddressRiskReport
     */
    'risk': number;
    /**
     * 
     * @type {AddressRiskReportDetails}
     * @memberof AddressRiskReport
     */
    'details': AddressRiskReportDetails;
}
/**
 * 
 * @export
 * @interface AddressRiskReportDetails
 */
export interface AddressRiskReportDetails {
    /**
     * 
     * @type {Array<RiskReportCategory>}
     * @memberof AddressRiskReportDetails
     */
    'own_categories'?: Array<RiskReportCategory>;
    /**
     * 
     * @type {Array<RiskReportCategory>}
     * @memberof AddressRiskReportDetails
     */
    'source_of_funds_categories'?: Array<RiskReportCategory>;
}
/**
 * Amount
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * 
     * @type {number}
     * @memberof Amount
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    'currency_name': string;
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    'currency_symbol': string;
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    'image_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    'image_url'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthUser200Response
 */
export interface AuthUser200Response {
    /**
     * UserJWT
     * @type {string}
     * @memberof AuthUser200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Balance200Response
 */
export interface Balance200Response {
    /**
     * 
     * @type {BalanceResponse}
     * @memberof Balance200Response
     */
    'balance': BalanceResponse;
}
/**
 * Represents a response from aggregated balance request.
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * 
     * @type {Array<Amount>}
     * @memberof BalanceResponse
     */
    'balance_sum': Array<Amount>;
    /**
     * 
     * @type {Array<BalanceResponseAccountsInner>}
     * @memberof BalanceResponse
     */
    'accounts': Array<BalanceResponseAccountsInner>;
}
/**
 * 
 * @export
 * @interface BalanceResponseAccountsInner
 */
export interface BalanceResponseAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof BalanceResponseAccountsInner
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof BalanceResponseAccountsInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BalanceResponseAccountsInner
     */
    'type': BalanceResponseAccountsInnerTypeEnum;
    /**
     * 
     * @type {Array<Amount>}
     * @memberof BalanceResponseAccountsInner
     */
    'balance': Array<Amount>;
    /**
     * 
     * @type {BalanceResponseAccountsInnerState}
     * @memberof BalanceResponseAccountsInner
     */
    'state': BalanceResponseAccountsInnerState;
    /**
     * 
     * @type {string}
     * @memberof BalanceResponseAccountsInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BalanceResponseAccountsInner
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof BalanceResponseAccountsInner
     */
    'url': string;
}

export const BalanceResponseAccountsInnerTypeEnum = {
    Wallet: 'crypto_wallet',
    Exchange: 'crypto_exchange',
    Nft: 'crypto_nft'
} as const;

export type BalanceResponseAccountsInnerTypeEnum = typeof BalanceResponseAccountsInnerTypeEnum[keyof typeof BalanceResponseAccountsInnerTypeEnum];

/**
 * 
 * @export
 * @interface BalanceResponseAccountsInnerState
 */
export interface BalanceResponseAccountsInnerState {
    /**
     * null if initial sync was not yet done
     * @type {string}
     * @memberof BalanceResponseAccountsInnerState
     */
    'last_sync'?: string | null;
}
/**
 * 
 * @export
 * @interface ConnectAccount200Response
 */
export interface ConnectAccount200Response {
    /**
     * 
     * @type {string}
     * @memberof ConnectAccount200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectAccount200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectAccount200Response
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectAccount200Response
     */
    'verified': boolean;
}
/**
 * 
 * @export
 * @interface ConnectAccount400Response
 */
export interface ConnectAccount400Response {
    /**
     * 
     * @type {string}
     * @memberof ConnectAccount400Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface ConnectAccount405Response
 */
export interface ConnectAccount405Response {
    /**
     * 
     * @type {string}
     * @memberof ConnectAccount405Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface ConnectAccountRequest
 */
export interface ConnectAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectAccountRequest
     */
    'wallet': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectAccountRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DeleteAccount404Response
 */
export interface DeleteAccount404Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteAccount404Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface DeleteUser200Response
 */
export interface DeleteUser200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteUser200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteUser404Response
 */
export interface DeleteUser404Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteUser404Response
     */
    'message'?: string;
}
/**
 * ExchangeRate
 * @export
 * @interface ExchangeRate
 */
export interface ExchangeRate {
    /**
     * 
     * @type {string}
     * @memberof ExchangeRate
     */
    'currency_pair': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeRate
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof ExchangeRate
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface GetAccountHint200Response
 */
export interface GetAccountHint200Response {
    /**
     * 
     * @type {string}
     * @memberof GetAccountHint200Response
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccountHint200Response
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccountHint200Response
     */
    'intro': string;
    /**
     * 
     * @type {GetAccountHint200ResponseFields}
     * @memberof GetAccountHint200Response
     */
    'fields': GetAccountHint200ResponseFields;
    /**
     * 
     * @type {boolean}
     * @memberof GetAccountHint200Response
     */
    'oauth': boolean;
}
/**
 * 
 * @export
 * @interface GetAccountHint200ResponseFields
 */
export interface GetAccountHint200ResponseFields {
    [key: string]: string | any;

    /**
     * 
     * @type {string}
     * @memberof GetAccountHint200ResponseFields
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccountHint200ResponseFields
     */
    'wallet'?: string;
}
/**
 * 
 * @export
 * @interface GetAccountHint403Response
 */
export interface GetAccountHint403Response {
    /**
     * 
     * @type {string}
     * @memberof GetAccountHint403Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface GetAccountHint404Response
 */
export interface GetAccountHint404Response {
    /**
     * 
     * @type {string}
     * @memberof GetAccountHint404Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetAddressNameInfo200Response
 */
export interface GetAddressNameInfo200Response {
    /**
     * 
     * @type {string}
     * @memberof GetAddressNameInfo200Response
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressNameInfo200Response
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface GetAddressRiskScore200Response
 */
export interface GetAddressRiskScore200Response {
    /**
     * 
     * @type {string}
     * @memberof GetAddressRiskScore200Response
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAddressRiskScore200Response
     */
    'risk'?: number;
}
/**
 * 
 * @export
 * @interface GetTransactionRiskScore200Response
 */
export interface GetTransactionRiskScore200Response {
    /**
     * 
     * @type {string}
     * @memberof GetTransactionRiskScore200Response
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionRiskScore200Response
     */
    'risk'?: number;
}
/**
 * 
 * @export
 * @interface GetUser404Response
 */
export interface GetUser404Response {
    /**
     * 
     * @type {string}
     * @memberof GetUser404Response
     */
    'message'?: string;
}
/**
 * String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces.
     * @type {string}
     * @memberof Metadata
     */
    'image'?: string;
    /**
     * String - The image URL that appears alongside the asset image on NFT platforms.
     * @type {string}
     * @memberof Metadata
     */
    'external_url'?: string;
    /**
     * String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal.
     * @type {string}
     * @memberof Metadata
     */
    'background_color'?: string;
    /**
     * String - Name of the NFT asset.
     * @type {string}
     * @memberof Metadata
     */
    'name'?: string;
    /**
     * String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)
     * @type {string}
     * @memberof Metadata
     */
    'description'?: string;
    /**
     * Object - Traits/attributes/characteristics for each NFT asset.
     * @type {Array<MetadataAttributesInner>}
     * @memberof Metadata
     */
    'attributes'?: Array<MetadataAttributesInner>;
    /**
     * 
     * @type {NftMedia}
     * @memberof Metadata
     */
    'media'?: NftMedia;
}
/**
 * 
 * @export
 * @interface MetadataAttributesInner
 */
export interface MetadataAttributesInner {
    /**
     * 
     * @type {string}
     * @memberof MetadataAttributesInner
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataAttributesInner
     */
    'trait_type'?: string;
}
/**
 * Movement
 * @export
 * @interface Movement
 */
export interface Movement {
    /**
     * 
     * @type {string}
     * @memberof Movement
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Movement
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof Movement
     */
    'currency_name': string;
    /**
     * 
     * @type {string}
     * @memberof Movement
     */
    'currency_symbol': string;
    /**
     * 
     * @type {number}
     * @memberof Movement
     */
    'value': number;
    /**
     * 
     * @type {boolean}
     * @memberof Movement
     */
    'owned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Movement
     */
    'fee': boolean;
    /**
     * 
     * @type {string}
     * @memberof Movement
     */
    'image_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Movement
     */
    'image_url'?: string | null;
}
/**
 * 
 * @export
 * @interface NFTMetadata200ResponseValue
 */
export interface NFTMetadata200ResponseValue {
    /**
     * 
     * @type {Array<OwnedNft>}
     * @memberof NFTMetadata200ResponseValue
     */
    'ownedNfts'?: Array<OwnedNft>;
    /**
     * String - Total number of NFTs owned by the given address.
     * @type {string}
     * @memberof NFTMetadata200ResponseValue
     */
    'totalCount'?: string;
    /**
     * String - The canonical head block hash of when your request was received
     * @type {string}
     * @memberof NFTMetadata200ResponseValue
     */
    'blockHash'?: string;
}
/**
 * 
 * @export
 * @interface NftContractMetadata
 */
export interface NftContractMetadata {
    /**
     * String - NFT contract name.
     * @type {string}
     * @memberof NftContractMetadata
     */
    'name'?: string;
    /**
     * String - NFT contract symbol abbreviation.
     * @type {string}
     * @memberof NftContractMetadata
     */
    'symbol'?: string;
    /**
     * String - Total number of NFTs in a given NFT collection.
     * @type {string}
     * @memberof NftContractMetadata
     */
    'totalSupply'?: string;
    /**
     * String - \'ERC721\' or \'ERC1155\'
     * @type {string}
     * @memberof NftContractMetadata
     */
    'tokenType'?: string;
}
/**
 * 
 * @export
 * @interface NftId
 */
export interface NftId {
    /**
     * String - The ID of the token. Can be in hex or decimal format.
     * @type {string}
     * @memberof NftId
     */
    'tokenId'?: string;
    /**
     * 
     * @type {NftIdTokenMetadata}
     * @memberof NftId
     */
    'tokenMetadata'?: NftIdTokenMetadata;
}
/**
 * 
 * @export
 * @interface NftIdTokenMetadata
 */
export interface NftIdTokenMetadata {
    /**
     * String - \'ERC721\' or \'ERC1155\'
     * @type {string}
     * @memberof NftIdTokenMetadata
     */
    'tokenType'?: string;
}
/**
 * 
 * @export
 * @interface NftMedia
 */
export interface NftMedia {
    /**
     * String - Uri representing the location of the NFT\'s original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated.
     * @type {string}
     * @memberof NftMedia
     */
    'raw'?: string;
    /**
     * String - Public gateway uri for the raw uri above.
     * @type {string}
     * @memberof NftMedia
     */
    'gateway'?: string;
    /**
     * URL for a resized thumbnail of the NFT media asset.
     * @type {string}
     * @memberof NftMedia
     */
    'thumbnail'?: string;
    /**
     * The media format (jpg, gif, png, etc.) of the gateway and thumbnail assets.
     * @type {string}
     * @memberof NftMedia
     */
    'format'?: string;
    /**
     * The size of the media asset in bytes.
     * @type {number}
     * @memberof NftMedia
     */
    'bytes'?: number;
}
/**
 * Information about whether and why a contract was marked as spam.
 * @export
 * @interface NftSpamInfo
 */
export interface NftSpamInfo {
    /**
     * \"true\" if contract is spam, else \"false\"
     * @type {string}
     * @memberof NftSpamInfo
     */
    'isSpam'?: string;
    /**
     * List of reasons why a contract was classified as spam.
     * @type {Array<string>}
     * @memberof NftSpamInfo
     */
    'classifications'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NftTokenUri
 */
export interface NftTokenUri {
    /**
     * String - Uri representing the location of the NFT\'s original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated.
     * @type {string}
     * @memberof NftTokenUri
     */
    'raw'?: string;
    /**
     * String - Public gateway uri for the raw uri above.
     * @type {string}
     * @memberof NftTokenUri
     */
    'gateway'?: string;
}
/**
 * OwnedNft
 * @export
 * @interface OwnedNft
 */
export interface OwnedNft {
    /**
     * 
     * @type {OwnedNftContract}
     * @memberof OwnedNft
     */
    'contract'?: OwnedNftContract;
    /**
     * 
     * @type {NftId}
     * @memberof OwnedNft
     */
    'id'?: NftId;
    /**
     * String - Token balance
     * @type {string}
     * @memberof OwnedNft
     */
    'balance'?: string;
    /**
     * String - Name of the NFT asset.
     * @type {string}
     * @memberof OwnedNft
     */
    'title'?: string;
    /**
     * String - Brief human-readable description
     * @type {string}
     * @memberof OwnedNft
     */
    'description'?: string;
    /**
     * 
     * @type {NftTokenUri}
     * @memberof OwnedNft
     */
    'tokenUri'?: NftTokenUri;
    /**
     * 
     * @type {OwnedNftMedia}
     * @memberof OwnedNft
     */
    'media'?: OwnedNftMedia;
    /**
     * 
     * @type {Metadata}
     * @memberof OwnedNft
     */
    'metadata'?: Metadata;
    /**
     * String - ISO timestamp of the last cache refresh for the information returned in the metadata field.
     * @type {string}
     * @memberof OwnedNft
     */
    'timeLastUpdated'?: string;
    /**
     * String - A string describing a particular reason that we were unable to fetch complete metadata for the NFT.
     * @type {string}
     * @memberof OwnedNft
     */
    'error'?: string;
    /**
     * 
     * @type {NftContractMetadata}
     * @memberof OwnedNft
     */
    'contractMetadata'?: NftContractMetadata;
    /**
     * 
     * @type {NftSpamInfo}
     * @memberof OwnedNft
     */
    'spamInfo'?: NftSpamInfo;
}
/**
 * Object - Contract for returned NFT
 * @export
 * @interface OwnedNftContract
 */
export interface OwnedNftContract {
    /**
     * String - Address of NFT contract.
     * @type {string}
     * @memberof OwnedNftContract
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface OwnedNftMedia
 */
export interface OwnedNftMedia {
    /**
     * String - Uri representing the location of the NFT\'s original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated.
     * @type {string}
     * @memberof OwnedNftMedia
     */
    'raw'?: string;
    /**
     * String - Public gateway uri for the raw uri above.
     * @type {string}
     * @memberof OwnedNftMedia
     */
    'gateway'?: string;
    /**
     * URL for a resized thumbnail of the NFT media asset.
     * @type {string}
     * @memberof OwnedNftMedia
     */
    'thumbnail'?: string;
    /**
     * The media format (jpg, gif, png, etc.) of the gateway and thumbnail assets.
     * @type {string}
     * @memberof OwnedNftMedia
     */
    'format'?: string;
    /**
     * The size of the media asset in bytes.
     * @type {number}
     * @memberof OwnedNftMedia
     */
    'bytes'?: number;
}
/**
 * RiskReportCategory
 * @export
 * @interface RiskReportCategory
 */
export interface RiskReportCategory {
    /**
     * 
     * @type {string}
     * @memberof RiskReportCategory
     */
    'adress'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskReportCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RiskReportCategory
     */
    'category_name': string;
    /**
     * 
     * @type {number}
     * @memberof RiskReportCategory
     */
    'risk': number;
}
/**
 * Represents a transaction.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'transaction_id': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'type': TransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'side'?: string;
    /**
     * 
     * @type {Array<Amount>}
     * @memberof Transaction
     */
    'amount': Array<Amount>;
    /**
     * 
     * @type {Array<Amount>}
     * @memberof Transaction
     */
    'total': Array<Amount>;
    /**
     * 
     * @type {Array<Amount>}
     * @memberof Transaction
     */
    'fee': Array<Amount>;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'created_at': string;
    /**
     * 
     * @type {Array<Movement>}
     * @memberof Transaction
     */
    'inputs': Array<Movement>;
    /**
     * 
     * @type {Array<Movement>}
     * @memberof Transaction
     */
    'outputs': Array<Movement>;
}

export const TransactionTypeEnum = {
    Wallet: 'crypto_wallet',
    Exchange: 'crypto_exchange',
    Nft: 'crypto_nft'
} as const;

export type TransactionTypeEnum = typeof TransactionTypeEnum[keyof typeof TransactionTypeEnum];

/**
 * TransactionRiskReport
 * @export
 * @interface TransactionRiskReport
 */
export interface TransactionRiskReport {
    /**
     * 
     * @type {string}
     * @memberof TransactionRiskReport
     */
    'case_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRiskReport
     */
    'request_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRiskReport
     */
    'response_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRiskReport
     */
    'transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRiskReport
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionRiskReport
     */
    'risk': number;
    /**
     * Keys are addresses from transaction inputs or outputs
     * @type {{ [key: string]: AddressRiskReportDetails; }}
     * @memberof TransactionRiskReport
     */
    'details': { [key: string]: AddressRiskReportDetails; };
}
/**
 * 
 * @export
 * @interface Transactions200Response
 */
export interface Transactions200Response {
    /**
     * Use this as `cursor` in the next request to get the next page. The `page_cursor` has a one hour validity.
     * @type {string}
     * @memberof Transactions200Response
     */
    'page_cursor'?: string;
    /**
     * 
     * @type {Array<Transactions200ResponseAccountsInner>}
     * @memberof Transactions200Response
     */
    'accounts'?: Array<Transactions200ResponseAccountsInner>;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof Transactions200Response
     */
    'transactions': Array<Transaction>;
}
/**
 * 
 * @export
 * @interface Transactions200ResponseAccountsInner
 */
export interface Transactions200ResponseAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof Transactions200ResponseAccountsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Transactions200ResponseAccountsInner
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Transactions200ResponseAccountsInner
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof Transactions200ResponseAccountsInner
     */
    'type': Transactions200ResponseAccountsInnerTypeEnum;
    /**
     * 
     * @type {BalanceResponseAccountsInnerState}
     * @memberof Transactions200ResponseAccountsInner
     */
    'state': BalanceResponseAccountsInnerState;
}

export const Transactions200ResponseAccountsInnerTypeEnum = {
    Wallet: 'crypto_wallet',
    Exchange: 'crypto_exchange',
    Nft: 'crypto_nft'
} as const;

export type Transactions200ResponseAccountsInnerTypeEnum = typeof Transactions200ResponseAccountsInnerTypeEnum[keyof typeof Transactions200ResponseAccountsInnerTypeEnum];

/**
 * Represents a user
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserAPIAuthenticateProject200Response
 */
export interface UserAPIAuthenticateProject200Response {
    /**
     * 
     * @type {string}
     * @memberof UserAPIAuthenticateProject200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UserAPIAuthenticateProject400Response
 */
export interface UserAPIAuthenticateProject400Response {
    /**
     * 
     * @type {string}
     * @memberof UserAPIAuthenticateProject400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserAPIAuthenticateProject401Response
 */
export interface UserAPIAuthenticateProject401Response {
    /**
     * 
     * @type {string}
     * @memberof UserAPIAuthenticateProject401Response
     */
    'message'?: string;
}

/**
 * AccountProviderInfoApi - axios parameter creator
 * @export
 */
export const AccountProviderInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Connect new account
         * @param {string} accountProvider URL value from account_providers method
         * @param {ConnectAccountRequest} [connectAccountRequest] OK
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAccount: async (accountProvider: string, connectAccountRequest?: ConnectAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountProvider' is not null or undefined
            assertParamExists('connectAccount', 'accountProvider', accountProvider)
            const localVarPath = `/v1/{account_provider}/connect`
                .replace(`{${"account_provider"}}`, encodeURIComponent(String(accountProvider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountProvider URL value from account_providers method
         * @param {string} accountId Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountProvider: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountProvider' is not null or undefined
            assertParamExists('deleteAccount', 'accountProvider', accountProvider)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/v1/{account_provider}/account/{account_id}`
                .replace(`{${"account_provider"}}`, encodeURIComponent(String(accountProvider)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account hint
         * @param {string} accountProvider URL value from account_providers method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountHint: async (accountProvider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountProvider' is not null or undefined
            assertParamExists('getAccountHint', 'accountProvider', accountProvider)
            const localVarPath = `/v1/{account_provider}/connect`
                .replace(`{${"account_provider"}}`, encodeURIComponent(String(accountProvider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountProviderInfoApi - functional programming interface
 * @export
 */
export const AccountProviderInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountProviderInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Connect new account
         * @param {string} accountProvider URL value from account_providers method
         * @param {ConnectAccountRequest} [connectAccountRequest] OK
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectAccount(accountProvider: string, connectAccountRequest?: ConnectAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectAccount(accountProvider, connectAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountProvider URL value from account_providers method
         * @param {string} accountId Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountProvider: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountProvider, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get account hint
         * @param {string} accountProvider URL value from account_providers method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountHint(accountProvider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountHint200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountHint(accountProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountProviderInfoApi - factory interface
 * @export
 */
export const AccountProviderInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountProviderInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Connect new account
         * @param {string} accountProvider URL value from account_providers method
         * @param {ConnectAccountRequest} [connectAccountRequest] OK
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAccount(accountProvider: string, connectAccountRequest?: ConnectAccountRequest, options?: any): AxiosPromise<ConnectAccount200Response> {
            return localVarFp.connectAccount(accountProvider, connectAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountProvider URL value from account_providers method
         * @param {string} accountId Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountProvider: string, accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccount(accountProvider, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account hint
         * @param {string} accountProvider URL value from account_providers method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountHint(accountProvider: string, options?: any): AxiosPromise<GetAccountHint200Response> {
            return localVarFp.getAccountHint(accountProvider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountProviderInfoApi - object-oriented interface
 * @export
 * @class AccountProviderInfoApi
 * @extends {BaseAPI}
 */
export class AccountProviderInfoApi extends BaseAPI {
    /**
     * 
     * @summary Connect new account
     * @param {string} accountProvider URL value from account_providers method
     * @param {ConnectAccountRequest} [connectAccountRequest] OK
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountProviderInfoApi
     */
    public connectAccount(accountProvider: string, connectAccountRequest?: ConnectAccountRequest, options?: AxiosRequestConfig) {
        return AccountProviderInfoApiFp(this.configuration).connectAccount(accountProvider, connectAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete account
     * @param {string} accountProvider URL value from account_providers method
     * @param {string} accountId Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountProviderInfoApi
     */
    public deleteAccount(accountProvider: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountProviderInfoApiFp(this.configuration).deleteAccount(accountProvider, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account hint
     * @param {string} accountProvider URL value from account_providers method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountProviderInfoApi
     */
    public getAccountHint(accountProvider: string, options?: AxiosRequestConfig) {
        return AccountProviderInfoApiFp(this.configuration).getAccountHint(accountProvider, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressNameAndCategoryInfoApi - axios parameter creator
 * @export
 */
export const AddressNameAndCategoryInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get address name and category info
         * @param {string} address Address for wich name and category should be returned
         * @param {string} chain Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressNameInfo: async (address: string, chain: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAddressNameInfo', 'address', address)
            // verify required parameter 'chain' is not null or undefined
            assertParamExists('getAddressNameInfo', 'chain', chain)
            const localVarPath = `/v1/addressname/simple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressNameAndCategoryInfoApi - functional programming interface
 * @export
 */
export const AddressNameAndCategoryInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressNameAndCategoryInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get address name and category info
         * @param {string} address Address for wich name and category should be returned
         * @param {string} chain Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressNameInfo(address: string, chain: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressNameInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressNameInfo(address, chain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressNameAndCategoryInfoApi - factory interface
 * @export
 */
export const AddressNameAndCategoryInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressNameAndCategoryInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get address name and category info
         * @param {string} address Address for wich name and category should be returned
         * @param {string} chain Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressNameInfo(address: string, chain: string, options?: any): AxiosPromise<GetAddressNameInfo200Response> {
            return localVarFp.getAddressNameInfo(address, chain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressNameAndCategoryInfoApi - object-oriented interface
 * @export
 * @class AddressNameAndCategoryInfoApi
 * @extends {BaseAPI}
 */
export class AddressNameAndCategoryInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get address name and category info
     * @param {string} address Address for wich name and category should be returned
     * @param {string} chain Blockchain identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressNameAndCategoryInfoApi
     */
    public getAddressNameInfo(address: string, chain: string, options?: AxiosRequestConfig) {
        return AddressNameAndCategoryInfoApiFp(this.configuration).getAddressNameInfo(address, chain, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AggregatedInfoApi - axios parameter creator
 * @export
 */
export const AggregatedInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get list of account providers hints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountProviderHintsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/aggregate/account_provider_hints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of account providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountProvidersList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/aggregate/account_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/aggregate/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get balance
         * @param {string} [currency] Currency to convert to. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: async (currency?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/aggregate/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get NFT metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFTMetadata: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/aggregate/nft_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactions
         * @param {string} [since] Set time from which the transactions will be get. 
         * @param {string} [until] Set time to which the transactions will be get. The default value is the actual date. 
         * @param {number} [limit] Limit the number of the transactions in the response. Default page size is 50. 
         * @param {string} [cursor] Specify on requesting the next page. Use the &#x60;page_cursor&#x60; from the previous response. 
         * @param {string} [currency] Currency to convert to. 
         * @param {string} [accountFilter] Filter results to only provided account. When omitted, it returns all transactions from all accounts. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactions: async (since?: string, until?: string, limit?: number, cursor?: string, currency?: string, accountFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/aggregate/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString().substr(0,10) :
                    since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = (until as any instanceof Date) ?
                    (until as any).toISOString().substr(0,10) :
                    until;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (accountFilter !== undefined) {
                localVarQueryParameter['account-filter'] = accountFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AggregatedInfoApi - functional programming interface
 * @export
 */
export const AggregatedInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AggregatedInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get list of account providers hints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountProviderHintsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountProviderHint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountProviderHintsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of account providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountProvidersList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountProvidersList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get balance
         * @param {string} [currency] Currency to convert to. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balance(currency?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balance(currency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get NFT metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nFTMetadata(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: NFTMetadata200ResponseValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nFTMetadata(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transactions
         * @param {string} [since] Set time from which the transactions will be get. 
         * @param {string} [until] Set time to which the transactions will be get. The default value is the actual date. 
         * @param {number} [limit] Limit the number of the transactions in the response. Default page size is 50. 
         * @param {string} [cursor] Specify on requesting the next page. Use the &#x60;page_cursor&#x60; from the previous response. 
         * @param {string} [currency] Currency to convert to. 
         * @param {string} [accountFilter] Filter results to only provided account. When omitted, it returns all transactions from all accounts. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactions(since?: string, until?: string, limit?: number, cursor?: string, currency?: string, accountFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactions(since, until, limit, cursor, currency, accountFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AggregatedInfoApi - factory interface
 * @export
 */
export const AggregatedInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AggregatedInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get list of account providers hints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountProviderHintsList(options?: any): AxiosPromise<AccountProviderHint> {
            return localVarFp.accountProviderHintsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of account providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountProvidersList(options?: any): AxiosPromise<AccountProvider> {
            return localVarFp.accountProvidersList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts(options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.accounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get balance
         * @param {string} [currency] Currency to convert to. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance(currency?: string, options?: any): AxiosPromise<Balance200Response> {
            return localVarFp.balance(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get NFT metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFTMetadata(options?: any): AxiosPromise<{ [key: string]: NFTMetadata200ResponseValue; }> {
            return localVarFp.nFTMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transactions
         * @param {string} [since] Set time from which the transactions will be get. 
         * @param {string} [until] Set time to which the transactions will be get. The default value is the actual date. 
         * @param {number} [limit] Limit the number of the transactions in the response. Default page size is 50. 
         * @param {string} [cursor] Specify on requesting the next page. Use the &#x60;page_cursor&#x60; from the previous response. 
         * @param {string} [currency] Currency to convert to. 
         * @param {string} [accountFilter] Filter results to only provided account. When omitted, it returns all transactions from all accounts. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactions(since?: string, until?: string, limit?: number, cursor?: string, currency?: string, accountFilter?: string, options?: any): AxiosPromise<Transactions200Response> {
            return localVarFp.transactions(since, until, limit, cursor, currency, accountFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AggregatedInfoApi - object-oriented interface
 * @export
 * @class AggregatedInfoApi
 * @extends {BaseAPI}
 */
export class AggregatedInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get list of account providers hints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatedInfoApi
     */
    public accountProviderHintsList(options?: AxiosRequestConfig) {
        return AggregatedInfoApiFp(this.configuration).accountProviderHintsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of account providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatedInfoApi
     */
    public accountProvidersList(options?: AxiosRequestConfig) {
        return AggregatedInfoApiFp(this.configuration).accountProvidersList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatedInfoApi
     */
    public accounts(options?: AxiosRequestConfig) {
        return AggregatedInfoApiFp(this.configuration).accounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get balance
     * @param {string} [currency] Currency to convert to. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatedInfoApi
     */
    public balance(currency?: string, options?: AxiosRequestConfig) {
        return AggregatedInfoApiFp(this.configuration).balance(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get NFT metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatedInfoApi
     */
    public nFTMetadata(options?: AxiosRequestConfig) {
        return AggregatedInfoApiFp(this.configuration).nFTMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transactions
     * @param {string} [since] Set time from which the transactions will be get. 
     * @param {string} [until] Set time to which the transactions will be get. The default value is the actual date. 
     * @param {number} [limit] Limit the number of the transactions in the response. Default page size is 50. 
     * @param {string} [cursor] Specify on requesting the next page. Use the &#x60;page_cursor&#x60; from the previous response. 
     * @param {string} [currency] Currency to convert to. 
     * @param {string} [accountFilter] Filter results to only provided account. When omitted, it returns all transactions from all accounts. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatedInfoApi
     */
    public transactions(since?: string, until?: string, limit?: number, cursor?: string, currency?: string, accountFilter?: string, options?: AxiosRequestConfig) {
        return AggregatedInfoApiFp(this.configuration).transactions(since, until, limit, cursor, currency, accountFilter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate developer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIAuthenticateDeveloper: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/developer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIAuthenticateProject: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate developer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAPIAuthenticateDeveloper(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAPIAuthenticateProject200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAPIAuthenticateDeveloper(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Authenticate project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAPIAuthenticateProject(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAPIAuthenticateProject200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAPIAuthenticateProject(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate developer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIAuthenticateDeveloper(options?: any): AxiosPromise<UserAPIAuthenticateProject200Response> {
            return localVarFp.userAPIAuthenticateDeveloper(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIAuthenticateProject(options?: any): AxiosPromise<UserAPIAuthenticateProject200Response> {
            return localVarFp.userAPIAuthenticateProject(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate developer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public userAPIAuthenticateDeveloper(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).userAPIAuthenticateDeveloper(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public userAPIAuthenticateProject(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).userAPIAuthenticateProject(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExchangeRateInfoApi - axios parameter creator
 * @export
 */
export const ExchangeRateInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current exchange rate
         * @param {string} pairs Currency pairs for which exchange rate should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentExchangeRate: async (pairs: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pairs' is not null or undefined
            assertParamExists('getCurrentExchangeRate', 'pairs', pairs)
            const localVarPath = `/v1/exchangerate/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pairs !== undefined) {
                localVarQueryParameter['pairs'] = pairs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get historical exchange rate
         * @param {string} pair Currency pair for which exchange rates should be returned
         * @param {string} days Historical dates for which exchange rates should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalExchangeRate: async (pair: string, days: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getHistoricalExchangeRate', 'pair', pair)
            // verify required parameter 'days' is not null or undefined
            assertParamExists('getHistoricalExchangeRate', 'days', days)
            const localVarPath = `/v1/exchangerate/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeRateInfoApi - functional programming interface
 * @export
 */
export const ExchangeRateInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangeRateInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current exchange rate
         * @param {string} pairs Currency pairs for which exchange rate should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentExchangeRate(pairs: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExchangeRate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentExchangeRate(pairs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get historical exchange rate
         * @param {string} pair Currency pair for which exchange rates should be returned
         * @param {string} days Historical dates for which exchange rates should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalExchangeRate(pair: string, days: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExchangeRate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalExchangeRate(pair, days, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExchangeRateInfoApi - factory interface
 * @export
 */
export const ExchangeRateInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangeRateInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current exchange rate
         * @param {string} pairs Currency pairs for which exchange rate should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentExchangeRate(pairs: string, options?: any): AxiosPromise<Array<ExchangeRate>> {
            return localVarFp.getCurrentExchangeRate(pairs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get historical exchange rate
         * @param {string} pair Currency pair for which exchange rates should be returned
         * @param {string} days Historical dates for which exchange rates should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalExchangeRate(pair: string, days: string, options?: any): AxiosPromise<Array<ExchangeRate>> {
            return localVarFp.getHistoricalExchangeRate(pair, days, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangeRateInfoApi - object-oriented interface
 * @export
 * @class ExchangeRateInfoApi
 * @extends {BaseAPI}
 */
export class ExchangeRateInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get current exchange rate
     * @param {string} pairs Currency pairs for which exchange rate should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeRateInfoApi
     */
    public getCurrentExchangeRate(pairs: string, options?: AxiosRequestConfig) {
        return ExchangeRateInfoApiFp(this.configuration).getCurrentExchangeRate(pairs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get historical exchange rate
     * @param {string} pair Currency pair for which exchange rates should be returned
     * @param {string} days Historical dates for which exchange rates should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeRateInfoApi
     */
    public getHistoricalExchangeRate(pair: string, days: string, options?: AxiosRequestConfig) {
        return ExchangeRateInfoApiFp(this.configuration).getHistoricalExchangeRate(pair, days, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RiskInfoApi - axios parameter creator
 * @export
 */
export const RiskInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get address risk score
         * @param {string} [address] Address for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressRiskScore: async (address?: string, chain?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/risk/score`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address risk score case
         * @param {string} caseId Case identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressRiskScoreCase: async (caseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('getAddressRiskScoreCase', 'caseId', caseId)
            const localVarPath = `/v1/risk/score/details/{case_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address risk score details
         * @param {string} [address] Address for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressRiskScoreDetails: async (address?: string, chain?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/risk/score/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction risk score
         * @param {string} [transaction] Transaction hash for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRiskScore: async (transaction?: string, chain?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/risk/transaction/score`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (transaction !== undefined) {
                localVarQueryParameter['transaction'] = transaction;
            }

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction risk score case
         * @param {string} caseId Case identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRiskScoreCase: async (caseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('getTransactionRiskScoreCase', 'caseId', caseId)
            const localVarPath = `/v1/risk/transaction/score/details/{case_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction risk score details
         * @param {string} [transaction] Transaction hash for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRiskScoreDetails: async (transaction?: string, chain?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/risk/transaction/score/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserJWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (transaction !== undefined) {
                localVarQueryParameter['transaction'] = transaction;
            }

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RiskInfoApi - functional programming interface
 * @export
 */
export const RiskInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RiskInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get address risk score
         * @param {string} [address] Address for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressRiskScore(address?: string, chain?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressRiskScore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressRiskScore(address, chain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get address risk score case
         * @param {string} caseId Case identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressRiskScoreCase(caseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressRiskReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressRiskScoreCase(caseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get address risk score details
         * @param {string} [address] Address for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressRiskScoreDetails(address?: string, chain?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressRiskReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressRiskScoreDetails(address, chain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction risk score
         * @param {string} [transaction] Transaction hash for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRiskScore(transaction?: string, chain?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionRiskScore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRiskScore(transaction, chain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction risk score case
         * @param {string} caseId Case identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRiskScoreCase(caseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRiskReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRiskScoreCase(caseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction risk score details
         * @param {string} [transaction] Transaction hash for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRiskScoreDetails(transaction?: string, chain?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRiskReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRiskScoreDetails(transaction, chain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RiskInfoApi - factory interface
 * @export
 */
export const RiskInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RiskInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get address risk score
         * @param {string} [address] Address for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressRiskScore(address?: string, chain?: string, options?: any): AxiosPromise<GetAddressRiskScore200Response> {
            return localVarFp.getAddressRiskScore(address, chain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address risk score case
         * @param {string} caseId Case identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressRiskScoreCase(caseId: string, options?: any): AxiosPromise<AddressRiskReport> {
            return localVarFp.getAddressRiskScoreCase(caseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address risk score details
         * @param {string} [address] Address for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressRiskScoreDetails(address?: string, chain?: string, options?: any): AxiosPromise<AddressRiskReport> {
            return localVarFp.getAddressRiskScoreDetails(address, chain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction risk score
         * @param {string} [transaction] Transaction hash for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRiskScore(transaction?: string, chain?: string, options?: any): AxiosPromise<GetTransactionRiskScore200Response> {
            return localVarFp.getTransactionRiskScore(transaction, chain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction risk score case
         * @param {string} caseId Case identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRiskScoreCase(caseId: string, options?: any): AxiosPromise<TransactionRiskReport> {
            return localVarFp.getTransactionRiskScoreCase(caseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction risk score details
         * @param {string} [transaction] Transaction hash for which risk should be returned
         * @param {string} [chain] Blockchain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRiskScoreDetails(transaction?: string, chain?: string, options?: any): AxiosPromise<TransactionRiskReport> {
            return localVarFp.getTransactionRiskScoreDetails(transaction, chain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RiskInfoApi - object-oriented interface
 * @export
 * @class RiskInfoApi
 * @extends {BaseAPI}
 */
export class RiskInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get address risk score
     * @param {string} [address] Address for which risk should be returned
     * @param {string} [chain] Blockchain identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskInfoApi
     */
    public getAddressRiskScore(address?: string, chain?: string, options?: AxiosRequestConfig) {
        return RiskInfoApiFp(this.configuration).getAddressRiskScore(address, chain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address risk score case
     * @param {string} caseId Case identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskInfoApi
     */
    public getAddressRiskScoreCase(caseId: string, options?: AxiosRequestConfig) {
        return RiskInfoApiFp(this.configuration).getAddressRiskScoreCase(caseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address risk score details
     * @param {string} [address] Address for which risk should be returned
     * @param {string} [chain] Blockchain identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskInfoApi
     */
    public getAddressRiskScoreDetails(address?: string, chain?: string, options?: AxiosRequestConfig) {
        return RiskInfoApiFp(this.configuration).getAddressRiskScoreDetails(address, chain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction risk score
     * @param {string} [transaction] Transaction hash for which risk should be returned
     * @param {string} [chain] Blockchain identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskInfoApi
     */
    public getTransactionRiskScore(transaction?: string, chain?: string, options?: AxiosRequestConfig) {
        return RiskInfoApiFp(this.configuration).getTransactionRiskScore(transaction, chain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction risk score case
     * @param {string} caseId Case identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskInfoApi
     */
    public getTransactionRiskScoreCase(caseId: string, options?: AxiosRequestConfig) {
        return RiskInfoApiFp(this.configuration).getTransactionRiskScoreCase(caseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction risk score details
     * @param {string} [transaction] Transaction hash for which risk should be returned
     * @param {string} [chain] Blockchain identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskInfoApi
     */
    public getTransactionRiskScoreDetails(transaction?: string, chain?: string, options?: AxiosRequestConfig) {
        return RiskInfoApiFp(this.configuration).getTransactionRiskScoreDetails(transaction, chain, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserManagementApi - axios parameter creator
 * @export
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authUser', 'id', id)
            const localVarPath = `/v1/users/{id}/auth`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create user
         * @param {CreateUserRequest} [createUserRequest] User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest?: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {string} id User id
         * @param {CreateUserRequest} [createUserRequest] User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, createUserRequest?: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ProjectToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementApi - functional programming interface
 * @export
 */
export const UserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create user
         * @param {CreateUserRequest} [createUserRequest] User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest?: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user
         * @param {string} id User id
         * @param {CreateUserRequest} [createUserRequest] User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, createUserRequest?: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserManagementApi - factory interface
 * @export
 */
export const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(id: string, options?: any): AxiosPromise<AuthUser200Response> {
            return localVarFp.authUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create user
         * @param {CreateUserRequest} [createUserRequest] User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest?: CreateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<DeleteUser200Response> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {string} id User id
         * @param {CreateUserRequest} [createUserRequest] User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, createUserRequest?: CreateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(id, createUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementApi - object-oriented interface
 * @export
 * @class UserManagementApi
 * @extends {BaseAPI}
 */
export class UserManagementApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate user
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public authUser(id: string, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).authUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create user
     * @param {CreateUserRequest} [createUserRequest] User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public createUser(createUserRequest?: CreateUserRequest, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public listUsers(options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {string} id User id
     * @param {CreateUserRequest} [createUserRequest] User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public updateUser(id: string, createUserRequest?: CreateUserRequest, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).updateUser(id, createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


